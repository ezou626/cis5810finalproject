import cv2
import os
import numpy as np
import asyncio
from dotenv import load_dotenv
import sys

load_dotenv('./server/.env', override=True)
READ_LIMIT = 2**18

#test_stream: 'http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'

def get_video_metadata(video_url: str) -> tuple[int, int, int]:
    """Get video metadata from a given URL

    Args:
        video_url (str): a URL to a video stream

    Returns:
        tuple[int, int, int]: a tuple containing the framerate, width, and height of the video stream
    """
    cap = cv2.VideoCapture(video_url)
    framerate = round(cap.get(5))
    width  = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    cap.release()

    return framerate, width, height

async def frame_generator(video_url: str):
    """Yields each frame of a video as generated by ffmpeg

    Args:
        video_url (str): a URL to a video stream

    Yields:
        np.ndarray: a numpy image in BGR format
    """
    _, width, height = get_video_metadata(video_url)
    # start ffmpeg
    command = [
        os.environ.get('FFMPEG_PATH'),
        '-max_delay', '30000000',   # 30 seconds
        '-i', video_url,
        '-f', 'rawvideo',
        '-pix_fmt', 'bgr24',
        '-an', 
        'pipe:'
    ]
    ffmpeg_process = await asyncio.create_subprocess_exec(
        *command, 
        stderr=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        limit=READ_LIMIT
    )

    frame_size = width * height * 3
    buffer = b''
    try:
        while True:
            chunk = await ffmpeg_process.stdout.read(READ_LIMIT)  # Read in chunks
            if not chunk:
                break  # End of stream

            buffer += chunk  # Add chunk to buffer

            # If enough data has been accumulated for a full frame
            while len(buffer) >= frame_size:
                frame = buffer[:frame_size]  # Take the first complete frame
                buffer = buffer[frame_size:]  # Keep the remaining data

                # Convert the frame to a numpy array (BGR format)
                yield np.frombuffer(frame, np.uint8).reshape((height, width, 3))

    except Exception as e:
        print(f"Error during frame extraction: {e}", file=sys.stderr)
    finally:
        # Log stderr output from ffmpeg for any errors or warnings
        stderr_output = await ffmpeg_process.stderr.read()
        if stderr_output:
            print(f"FFMPEG STDERR: {stderr_output.decode()}", file=sys.stderr)

        ffmpeg_process.terminate()
        await ffmpeg_process.wait()
        print("FFMPEG process terminated.", file=sys.stderr)